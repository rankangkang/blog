---
title: JS事件循环机制--event loop
tags: 
  - js
date: 2021-06-30 22:08:30
---



# JS事件循环机制——event loop

## 浏览器

**js运行在浏览器中是单线程的**，即js代码始终在一个线程上执行，该线程被称为js引擎线程。

但是**浏览器是多线程的**。在浏览器中运行的线程有：

* js引擎线程：用于执行js任务。（包含一个主线程与若干后台进程。）
* ui渲染线程： 用于渲染页面
* 浏览器事件触发线程：用于控制交互，响应用户
* HTTP请求线程：用于处理请求，Ajax是委托给浏览器新开一个HTTP线程。
* EventLoop轮询的事件处理处理线程：处理用于轮询的消息队列
* 定时器触发线程

其中js引擎线程、GUI线程和浏览器事件线程为常驻线程。



## JS引擎线程

js引擎线程就是js内核，负责解析与执行js代码，也称为主线程。浏览器同时只能有一个JS引擎线程在运行JS程序。js代码只能在一个线程上执行，同一时间只能执行一个任务，其他的任务会排队执行，所以js是单线程运行的。

需要注意的是，js引擎线程和GUI渲染线程同时只能有一个工作，js引擎线程会阻塞GUI渲染线程。



## 调用栈与执行上下文

所有的 JS 代码在运行时都是在执行上下文中进行的。执行上下文是一个抽象的概念，JS 中有三种执行上下文：

- 全局执行上下文，默认的，在浏览器中是 window 对象，并且 this 在非严格模式下指向它
- 函数执行上下文，JS 的函数每当被调用时会创建一个上下文
- Eval 执行上下文，eval 函数会产生自己的上下文，这里不讨论

通常，我们的代码中都不止一个上下文，那这些上下文的执行顺序应该是怎样的？从上往下依次执行？

栈，是一种数据结构，具有先进后出的原则。JS 中的执行栈就具有这样的结构，当引擎第一次遇到 JS 代码时，会产生一个全局执行上下文并压入执行栈，每遇到一个函数调用，就会往栈中压入一个新的上下文。引擎执行栈顶的函数，执行完毕，弹出当前执行上下文。

总结就是：调用栈采用先进先出 的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完之后，就会从栈顶移出，直至栈被清空。

## 任务队列

js运行时，除了一个运行线程，引擎还提供一个消息队列，里面是各种需要当前程序处理的消息。**新的消息进入队列时，会自动排在队列的尾端。**

* 消息（任务）和回调函数相互联系。

  单线程意味着js任务需要排队，若前一个任务出现大量的耗时操作，后面的任务得不到执行，任务的积累会导致页面的”假死“。



## 同步任务与异步任务

同步任务会在调用栈中按照顺序等待主线程依次执行。

异步任务会在异步有了结果之后，将注册的回调函数放入消息队列中等待主线程空闲（执行栈为空）时，被读取到栈内等待主线程执行。

同一执行上下文（层级）的同步任务总是先于异步任务执行。



## 事件循环 event loop

简单说，浏览器中的的两个线程：一个是引擎线程（主线程）；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为”Event Loop线程”（可以译为”消息线程”）。`该线程用于处理消息轮询`。

当执行栈为空时，主线程从“任务队列”中读取事件放入执行栈（调用栈）执行。当调用栈为空时，重复这个动作，如此往复。

有图示如下：

![preview](https://pic4.zhimg.com/v2-da078fa3eadf3db4bf455904ae06f84b_r.jpg)

JS引擎线程遇到异步（DOM事件监听、网络请求、setTimeout计时器等...），会交给相应的线程单独去维护异步任务，等待某个时机（计时器结束、网络请求成功、用户点击DOM），然后由 **事件触发线程** 将异步对应的 **回调函数** 加入到消息队列中，消息队列中的回调函数等待被执行。

## 异步队列

JS异步队列中的任务被分为两种，宏任务（MacroTask）与微任务（MicroTask）。宏任务组成的队列为宏队列，微任务组成的队列为微队列。

`宏任务`：script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering.

`微任务`：process.nextTick, Promise.then, Object.observer, MutationObserver.

### 宏任务与微任务的执行机制

1. 执行一个宏任务（栈中没有就从事件队列中获取）
2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
5. 渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取）

![img](https://pic2.zhimg.com/v2-d1ca0d6b13501044a5f74c99becbcd3d_b.webp)

![img](https://pic3.zhimg.com/80/v2-d6406cc50f2f5f2c9080101e1f07bd7e_720w.jpg)

即`宏队列与微队列`，**优先执行微队列中的任务.每次执行完宏队列中的任务后,都会查看微队列中是否有任务.假如有任务则先执行微队列中的任务.再执行宏队列中的任务**.

```js
/*
	代码模拟
*/
setTimeout(() => {
  console.log('宏队列 11 ');
  setTimeout(() => {
    console.log('宏队列 ' + 111);
  }, 0);
  Promise.resolve(3).then(val => {
    console.log('微队列 ' + val);
  });
}, 0);

setTimeout(() => {
  setTimeout(() => {
    console.log('宏队列 ' + 222);
  }, 6000);
  console.log('宏队列 22 ');
}, 0);

for(let i =1; i <= 5; i++){
  setTimeout(() => {
    console.log('宏队列 ' + i);
    new Promise(res => {
      console.log('promise ' + i);
      res();
    }).then(() => {
      console.log('微队列 ' + i);
    })
  }, i * 1000);

  console.log('宏队列 script ' + i);
}

Promise.resolve(1).then(val => {
  console.log('微队列 ' + val);
})

Promise.resolve(2).then(val => {
  console.log('微队列 ' + val);
})

/**
	以上代码得到控制台输出如下：
	
	宏队列 script 1
    宏队列 script 2
    宏队列 script 3
    宏队列 script 4
    宏队列 script 5
    微队列 1
    微队列 2
    宏队列 11 
    微队列 3
    宏队列 22 
    宏队列 111
    宏队列 1
    promise 1
    微队列 1
    宏队列 2
    promise 2
    微队列 2
    宏队列 3
    promise 3
    微队列 3
    宏队列 4
    promise 4
    微队列 4
    宏队列 5
    promise 5
    微队列 5
    宏队列 222

	推测法则如下：
	1. 执行时，会将代码扫描一遍，且扫描时，先执行全局队列的script，即未被setTimeout\Promise等包含的代码，把微任务依次放入微队列，宏任务依次放入宏队列。（一层一层拨开）
	2. 全局script执行完后，将执行微队列内的任务，待微队列为空后，执行宏队列内的任务。若微队列任务的代码中含有全局script代码，则先执行宏代码，再执行微任务；若微队列任务的代码中含有宏任务代码，则将宏任务依次放入宏队列，等待执行。
	3. 当微队列为空后，执行宏队列内的代码。遇到微任务则将该任务放入队列并执行微队列内的任务。回到2.
*/
```

推测法则如下：

1. 执行时，会将代码扫描一遍，且扫描时，先执行全局队列的script，即未被setTimeout\Promise等包含的代码，把微任务依次放入微队列，宏任务依次放入宏队列。（一层一层拨开）
2. 全局script执行完后，将执行微队列内的任务，待微队列为空后，执行宏队列内的任务。若微队列任务的代码中含有全局script代码，则先执行宏代码，再执行微任务；若微队列任务的代码中含有宏任务代码，则将宏任务依次放入宏队列，等待执行。
3. 当微队列为空后，执行宏队列内的代码。遇到微任务则将该任务放入队列并执行微队列内的任务。回到2.

